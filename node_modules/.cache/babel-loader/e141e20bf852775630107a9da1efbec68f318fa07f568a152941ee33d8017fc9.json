{"ast":null,"code":"/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject\";\nimport { base64Encode } from \"../../internal/utils/base64Encode\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts\";\nimport { smartEscape } from \"../utils/smartEscape\";\nexport function textStyle(layer) {\n  const keywords = [];\n  let style = \"\";\n  Object.keys(LAYER_KEYWORD_PARAMS).forEach(attr => {\n    let default_value = LAYER_KEYWORD_PARAMS[attr];\n    let attr_value = layer[attr] || default_value;\n    if (attr_value !== default_value) {\n      keywords.push(attr_value);\n    }\n  });\n  Object.keys(layer).forEach(attr => {\n    if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n      keywords.push(`${attr}_${layer[attr]}`);\n    }\n    if (attr === \"font_hinting\") {\n      keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n    }\n    if (attr === \"font_antialiasing\") {\n      keywords.push(`antialias_${layer[attr]}`);\n    }\n  });\n  if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n    if (!layer.font_size) throw `Must supply font_size for text in overlay/underlay`;\n    if (!layer.font_family) throw `Must supply font_family for text in overlay/underlay`;\n    keywords.unshift(layer.font_size);\n    keywords.unshift(layer.font_family);\n    style = keywords.filter(a => a).join(\"_\");\n  }\n  return style;\n}\nexport function processLayer(layer) {\n  let result = '';\n  if (isObject(layer)) {\n    if (layer.resource_type === \"fetch\" || layer.url != null) {\n      result = `fetch:${base64Encode(layer.url)}`;\n    } else {\n      let public_id = layer.public_id;\n      let format = layer.format;\n      let resource_type = layer.resource_type || \"image\";\n      let type = layer.type || \"upload\";\n      let text = layer.text;\n      let style = null;\n      let components = [];\n      const noPublicId = !public_id || public_id.length === 0;\n      if (!noPublicId) {\n        public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n        if (format != null) {\n          public_id = `${public_id}.${format}`;\n        }\n      }\n      if ((!text || text.length === 0) && resource_type !== \"text\") {\n        if (noPublicId) {\n          throw \"Must supply public_id for resource_type layer_parameter\";\n        }\n        if (resource_type === \"subtitles\") {\n          style = textStyle(layer);\n        }\n      } else {\n        resource_type = \"text\";\n        type = null;\n        // type is ignored for text layers\n        style = textStyle(layer);\n        if (text && text.length >= 0) {\n          const noStyle = !style;\n          if (!(noPublicId || noStyle) || noPublicId && noStyle) {\n            throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n          }\n          let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n          let start = 0;\n          let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n          text = \"\";\n          for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n            text += smartEscape(textSource.slice(start, res.index));\n            text += res[0];\n            start = res.index + res[0].length;\n          }\n          text += encodeURIComponent(textSource.slice(start));\n        }\n      }\n      if (resource_type !== \"image\") {\n        components.push(resource_type);\n      }\n      if (type !== \"upload\") {\n        components.push(type);\n      }\n      components.push(style);\n      components.push(public_id);\n      components.push(text);\n      result = components.filter(a => a).join(\":\");\n    }\n  } else if (/^fetch:.+/.test(layer)) {\n    result = `fetch:${base64Encode(layer.substr(6))}`;\n  } else {\n    result = layer;\n  }\n  return result;\n}","map":{"version":3,"names":["isObject","base64Encode","LAYER_KEYWORD_PARAMS","smartEscape","textStyle","layer","keywords","style","Object","keys","forEach","attr","default_value","attr_value","push","split","pop","hasOwnProperty","length","font_size","font_family","unshift","filter","a","join","processLayer","result","resource_type","url","public_id","format","type","text","components","noPublicId","replace","RegExp","noStyle","re","start","textSource","decodeURIComponent","res","exec","slice","index","encodeURIComponent","test","substr"],"sources":["D:/VSCode/Project_Market_Place/client/node_modules/@cloudinary/base/backwards/transformationProcessing/processLayer.js"],"sourcesContent":["/**\n * Parse layer options\n * @private\n * @param {object|*} layer The layer to parse.\n * @return {string} layer transformation string\n */\nimport { isObject } from \"../utils/isObject\";\nimport { base64Encode } from \"../../internal/utils/base64Encode\";\nimport { LAYER_KEYWORD_PARAMS } from \"../consts\";\nimport { smartEscape } from \"../utils/smartEscape\";\nexport function textStyle(layer) {\n    const keywords = [];\n    let style = \"\";\n    Object.keys(LAYER_KEYWORD_PARAMS).forEach((attr) => {\n        let default_value = LAYER_KEYWORD_PARAMS[attr];\n        let attr_value = layer[attr] || default_value;\n        if (attr_value !== default_value) {\n            keywords.push(attr_value);\n        }\n    });\n    Object.keys(layer).forEach((attr) => {\n        if (attr === \"letter_spacing\" || attr === \"line_spacing\") {\n            keywords.push(`${attr}_${layer[attr]}`);\n        }\n        if (attr === \"font_hinting\") {\n            keywords.push(`${attr.split(\"_\").pop()}_${layer[attr]}`);\n        }\n        if (attr === \"font_antialiasing\") {\n            keywords.push(`antialias_${layer[attr]}`);\n        }\n    });\n    if (layer.hasOwnProperty(\"font_size\" || \"font_family\") || !keywords || keywords.length === 0) {\n        if (!layer.font_size)\n            throw `Must supply font_size for text in overlay/underlay`;\n        if (!layer.font_family)\n            throw `Must supply font_family for text in overlay/underlay`;\n        keywords.unshift(layer.font_size);\n        keywords.unshift(layer.font_family);\n        style = keywords.filter((a) => a).join(\"_\");\n    }\n    return style;\n}\nexport function processLayer(layer) {\n    let result = '';\n    if (isObject(layer)) {\n        if (layer.resource_type === \"fetch\" || (layer.url != null)) {\n            result = `fetch:${base64Encode(layer.url)}`;\n        }\n        else {\n            let public_id = layer.public_id;\n            let format = layer.format;\n            let resource_type = layer.resource_type || \"image\";\n            let type = layer.type || \"upload\";\n            let text = layer.text;\n            let style = null;\n            let components = [];\n            const noPublicId = !public_id || public_id.length === 0;\n            if (!noPublicId) {\n                public_id = public_id.replace(new RegExp(\"/\", 'g'), \":\");\n                if (format != null) {\n                    public_id = `${public_id}.${format}`;\n                }\n            }\n            if ((!text || text.length === 0) && resource_type !== \"text\") {\n                if (noPublicId) {\n                    throw \"Must supply public_id for resource_type layer_parameter\";\n                }\n                if (resource_type === \"subtitles\") {\n                    style = textStyle(layer);\n                }\n            }\n            else {\n                resource_type = \"text\";\n                type = null;\n                // type is ignored for text layers\n                style = textStyle(layer);\n                if (text && text.length >= 0) {\n                    const noStyle = !style;\n                    if (!(noPublicId || noStyle) || (noPublicId && noStyle)) {\n                        throw \"Must supply either style parameters or a public_id when providing text parameter in a text overlay/underlay\";\n                    }\n                    let re = /\\$\\([a-zA-Z]\\w*\\)/g;\n                    let start = 0;\n                    let textSource = smartEscape(decodeURIComponent(text), /[,\\/]/g);\n                    text = \"\";\n                    for (let res = re.exec(textSource); res; res = re.exec(textSource)) {\n                        text += smartEscape(textSource.slice(start, res.index));\n                        text += res[0];\n                        start = res.index + res[0].length;\n                    }\n                    text += encodeURIComponent(textSource.slice(start));\n                }\n            }\n            if (resource_type !== \"image\") {\n                components.push(resource_type);\n            }\n            if (type !== \"upload\") {\n                components.push(type);\n            }\n            components.push(style);\n            components.push(public_id);\n            components.push(text);\n            result = components.filter((a) => a).join(\":\");\n        }\n    }\n    else if (/^fetch:.+/.test(layer)) {\n        result = `fetch:${base64Encode(layer.substr(6))}`;\n    }\n    else {\n        result = layer;\n    }\n    return result;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}